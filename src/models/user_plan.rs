/* 
 * GitHub
 *
 * Powerful collaboration, code review, and code management for open source and private projects. 
 *
 * OpenAPI spec version: v3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct UserPlan {
  #[serde(rename = "collaborators")]
  collaborators: Option<i32>,
  #[serde(rename = "name")]
  name: Option<String>,
  #[serde(rename = "private_repos")]
  private_repos: Option<i32>,
  #[serde(rename = "space")]
  space: Option<i32>
}

impl UserPlan {
  pub fn new() -> UserPlan {
    UserPlan {
      collaborators: None,
      name: None,
      private_repos: None,
      space: None
    }
  }

  pub fn set_collaborators(&mut self, collaborators: i32) {
    self.collaborators = Some(collaborators);
  }

  pub fn with_collaborators(mut self, collaborators: i32) -> UserPlan {
    self.collaborators = Some(collaborators);
    self
  }

  pub fn collaborators(&self) -> Option<&i32> {
    self.collaborators.as_ref()
  }

  pub fn reset_collaborators(&mut self) {
    self.collaborators = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> UserPlan {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_private_repos(&mut self, private_repos: i32) {
    self.private_repos = Some(private_repos);
  }

  pub fn with_private_repos(mut self, private_repos: i32) -> UserPlan {
    self.private_repos = Some(private_repos);
    self
  }

  pub fn private_repos(&self) -> Option<&i32> {
    self.private_repos.as_ref()
  }

  pub fn reset_private_repos(&mut self) {
    self.private_repos = None;
  }

  pub fn set_space(&mut self, space: i32) {
    self.space = Some(space);
  }

  pub fn with_space(mut self, space: i32) -> UserPlan {
    self.space = Some(space);
    self
  }

  pub fn space(&self) -> Option<&i32> {
    self.space.as_ref()
  }

  pub fn reset_space(&mut self) {
    self.space = None;
  }

}



