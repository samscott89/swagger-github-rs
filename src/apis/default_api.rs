/* 
 * GitHub
 *
 * Powerful collaboration, code review, and code management for open source and private projects. 
 *
 * OpenAPI spec version: v3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::rc::Rc;
use std::borrow::Borrow;
use std::borrow::Cow;
use std::collections::HashMap;

use hyper;
use serde_json;
use futures;
use futures::{Future, Stream};

use hyper::header::UserAgent;

use super::{Error, configuration};

pub struct DefaultApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> DefaultApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> DefaultApiClient<C> {
        DefaultApiClient {
            configuration: configuration,
        }
    }
}

pub trait DefaultApi {
    fn emojis_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Emojis, Error = Error<serde_json::Value>>>;
    fn events_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>>;
    fn feeds_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Feeds, Error = Error<serde_json::Value>>>;
    fn gists_get(&self, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gists, Error = Error<serde_json::Value>>>;
    fn gists_id_comments_comment_id_delete(&self, id: i32, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn gists_id_comments_comment_id_get(&self, id: i32, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Comment, Error = Error<serde_json::Value>>>;
    fn gists_id_comments_comment_id_patch(&self, id: i32, comment_id: i32, body: ::models::Comment, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Comment, Error = Error<serde_json::Value>>>;
    fn gists_id_comments_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Comments, Error = Error<serde_json::Value>>>;
    fn gists_id_comments_post(&self, id: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Comment, Error = Error<serde_json::Value>>>;
    fn gists_id_delete(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn gists_id_forks_post(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn gists_id_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gist, Error = Error<serde_json::Value>>>;
    fn gists_id_patch(&self, id: i32, body: ::models::PatchGist, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gist, Error = Error<serde_json::Value>>>;
    fn gists_id_star_delete(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn gists_id_star_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn gists_id_star_put(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn gists_post(&self, body: ::models::PostGist, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gist, Error = Error<serde_json::Value>>>;
    fn gists_public_get(&self, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gists, Error = Error<serde_json::Value>>>;
    fn gists_starred_get(&self, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gists, Error = Error<serde_json::Value>>>;
    fn gitignore_templates_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>>;
    fn gitignore_templates_language_get(&self, language: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::GitignoreLang, Error = Error<serde_json::Value>>>;
    fn issues_get(&self, filter: &str, state: &str, labels: &str, sort: &str, direction: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issues, Error = Error<serde_json::Value>>>;
    fn legacy_issues_search_owner_repository_state_keyword_get(&self, keyword: &str, state: &str, owner: &str, repository: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchIssuesByKeyword, Error = Error<serde_json::Value>>>;
    fn legacy_repos_search_keyword_get(&self, keyword: &str, order: &str, language: &str, start_page: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchRepositoriesByKeyword, Error = Error<serde_json::Value>>>;
    fn legacy_user_email_email_get(&self, email: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchUserByEmail, Error = Error<serde_json::Value>>>;
    fn legacy_user_search_keyword_get(&self, keyword: &str, order: &str, start_page: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchUsersByKeyword, Error = Error<serde_json::Value>>>;
    fn markdown_post(&self, body: ::models::Markdown, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn markdown_raw_post(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn meta_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Meta, Error = Error<serde_json::Value>>>;
    fn networks_owner_repo_events_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>>;
    fn notifications_get(&self, all: bool, participating: bool, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Notifications, Error = Error<serde_json::Value>>>;
    fn notifications_put(&self, body: ::models::NotificationMarkRead, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn notifications_threads_id_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Notifications, Error = Error<serde_json::Value>>>;
    fn notifications_threads_id_patch(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn notifications_threads_id_subscription_delete(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn notifications_threads_id_subscription_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Subscription, Error = Error<serde_json::Value>>>;
    fn notifications_threads_id_subscription_put(&self, id: i32, body: ::models::PutSubscription, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Subscription, Error = Error<serde_json::Value>>>;
    fn orgs_org_events_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>>;
    fn orgs_org_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Organization, Error = Error<serde_json::Value>>>;
    fn orgs_org_issues_get(&self, org: &str, filter: &str, state: &str, labels: &str, sort: &str, direction: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issues, Error = Error<serde_json::Value>>>;
    fn orgs_org_members_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn orgs_org_members_username_delete(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn orgs_org_members_username_get(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn orgs_org_patch(&self, org: &str, body: ::models::PatchOrg, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Organization, Error = Error<serde_json::Value>>>;
    fn orgs_org_public_members_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn orgs_org_public_members_username_delete(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn orgs_org_public_members_username_get(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn orgs_org_public_members_username_put(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn orgs_org_repos_get(&self, org: &str, _type: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>>;
    fn orgs_org_repos_post(&self, org: &str, body: ::models::PostRepo, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>>;
    fn orgs_org_teams_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Teams, Error = Error<serde_json::Value>>>;
    fn orgs_org_teams_post(&self, org: &str, body: ::models::OrgTeamsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Team, Error = Error<serde_json::Value>>>;
    fn rate_limit_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RateLimit, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_archive_format_path_get(&self, owner: &str, repo: &str, archive_format: &str, path: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_assignees_assignee_get(&self, owner: &str, repo: &str, assignee: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_assignees_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Assignees, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_branches_branch_get(&self, owner: &str, repo: &str, branch: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Branch, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_branches_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Branches, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_collaborators_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_collaborators_user_delete(&self, owner: &str, repo: &str, user: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_collaborators_user_get(&self, owner: &str, repo: &str, user: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_collaborators_user_put(&self, owner: &str, repo: &str, user: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_comments_comment_id_delete(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_comments_comment_id_get(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CommitComments, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_comments_comment_id_patch(&self, owner: &str, repo: &str, comment_id: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CommitComments, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_comments_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RepoComments, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_commits_get(&self, owner: &str, repo: &str, since: &str, sha: &str, path: &str, author: &str, until: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Commits, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_commits_ref_status_get(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RefStatus, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_commits_sha_code_comments_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RepoComments, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_commits_sha_code_comments_post(&self, owner: &str, repo: &str, sha_code: &str, body: ::models::CommitBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CommitComments, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_commits_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Commit, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_compare_base_id_head_id_get(&self, owner: &str, repo: &str, base_id: &str, head_id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CompareCommits, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_contents_path_delete(&self, owner: &str, repo: &str, path: &str, body: ::models::DeleteFileBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::DeleteFile, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_contents_path_get(&self, owner: &str, repo: &str, path: &str, path2: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ContentsPath, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_contents_path_put(&self, owner: &str, repo: &str, path: &str, body: ::models::CreateFileBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CreateFile, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_contributors_get(&self, owner: &str, repo: &str, anon: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Contributors, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_delete(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_deployments_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RepoDeployments, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_deployments_id_statuses_get(&self, owner: &str, repo: &str, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::DeploymentStatuses, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_deployments_id_statuses_post(&self, owner: &str, repo: &str, id: i32, body: ::models::DeploymentStatusesCreate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_deployments_post(&self, owner: &str, repo: &str, body: ::models::Deployment, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::DeploymentResp, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_downloads_download_id_delete(&self, owner: &str, repo: &str, download_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_downloads_download_id_get(&self, owner: &str, repo: &str, download_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Downloads, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_downloads_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Downloads, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_events_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_forks_get(&self, owner: &str, repo: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Forks, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_forks_post(&self, owner: &str, repo: &str, body: ::models::ForkBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Fork, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repo, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_blobs_post(&self, owner: &str, repo: &str, body: ::models::Blob, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Blobs, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_blobs_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Blob, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_commits_post(&self, owner: &str, repo: &str, body: ::models::RepoCommitBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::GitCommit, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_commits_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RepoCommit, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_refs_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Refs, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_refs_post(&self, owner: &str, repo: &str, body: ::models::RefsBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::HeadBranch, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_refs_ref_delete(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_refs_ref_get(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::HeadBranch, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_refs_ref_patch(&self, owner: &str, repo: &str, _ref: &str, body: ::models::GitRefPatch, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::HeadBranch, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_tags_post(&self, owner: &str, repo: &str, body: ::models::Tag, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Tags, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_tags_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Tag, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_trees_post(&self, owner: &str, repo: &str, body: ::models::Tree, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Trees, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_git_trees_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, recursive: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Tree, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_hooks_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Hook, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_hooks_hook_id_delete(&self, owner: &str, repo: &str, hook_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_hooks_hook_id_get(&self, owner: &str, repo: &str, hook_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Hook, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_hooks_hook_id_patch(&self, owner: &str, repo: &str, hook_id: i32, body: ::models::HookBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Hook, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_hooks_hook_id_tests_post(&self, owner: &str, repo: &str, hook_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_hooks_post(&self, owner: &str, repo: &str, body: ::models::HookBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Hook, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_comments_comment_id_delete(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_comments_comment_id_get(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComment, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_comments_comment_id_patch(&self, owner: &str, repo: &str, comment_id: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComment, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_comments_get(&self, owner: &str, repo: &str, direction: &str, sort: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComments, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_events_event_id_get(&self, owner: &str, repo: &str, event_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Event, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_events_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_get(&self, owner: &str, repo: &str, filter: &str, state: &str, labels: &str, sort: &str, direction: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issues, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_comments_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComments, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_comments_post(&self, owner: &str, repo: &str, number: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComment, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_events_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issue, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_labels_delete(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_labels_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Labels, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_labels_name_delete(&self, owner: &str, repo: &str, number: i32, name: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_labels_post(&self, owner: &str, repo: &str, number: i32, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_labels_put(&self, owner: &str, repo: &str, number: i32, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_number_patch(&self, owner: &str, repo: &str, number: i32, body: ::models::Issue, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issue, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_issues_post(&self, owner: &str, repo: &str, body: ::models::Issue, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issue, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_keys_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Keys, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_keys_key_id_delete(&self, owner: &str, repo: &str, key_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_keys_key_id_get(&self, owner: &str, repo: &str, key_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserKeysKeyId, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_keys_post(&self, owner: &str, repo: &str, body: ::models::UserKeysPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserKeysKeyId, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_labels_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Labels, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_labels_name_delete(&self, owner: &str, repo: &str, name: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_labels_name_get(&self, owner: &str, repo: &str, name: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_labels_name_patch(&self, owner: &str, repo: &str, name: &str, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_labels_post(&self, owner: &str, repo: &str, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_languages_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Languages, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_merges_post(&self, owner: &str, repo: &str, body: ::models::MergesBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::MergesSuccessful, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_milestones_get(&self, owner: &str, repo: &str, state: &str, direction: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Milestone, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_milestones_number_delete(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_milestones_number_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Milestone, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_milestones_number_labels_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Labels, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_milestones_number_patch(&self, owner: &str, repo: &str, number: i32, body: ::models::MilestoneUpdate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Milestone, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_milestones_post(&self, owner: &str, repo: &str, body: ::models::MilestoneUpdate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Milestone, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_notifications_get(&self, owner: &str, repo: &str, all: bool, participating: bool, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Notifications, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_notifications_put(&self, owner: &str, repo: &str, body: ::models::NotificationMarkRead, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_patch(&self, owner: &str, repo: &str, body: ::models::RepoEdit, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repo, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_comments_comment_id_delete(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_comments_comment_id_get(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullsComment, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_comments_comment_id_patch(&self, owner: &str, repo: &str, comment_id: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullsComment, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_comments_get(&self, owner: &str, repo: &str, direction: &str, sort: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComments, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_get(&self, owner: &str, repo: &str, state: &str, head: &str, base: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Pulls, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_number_comments_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullsComment, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_number_comments_post(&self, owner: &str, repo: &str, number: i32, body: ::models::PullsCommentPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullsComment, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_number_commits_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Commits, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_number_files_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Pulls, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_number_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullRequest, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_number_merge_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_number_merge_put(&self, owner: &str, repo: &str, number: i32, body: ::models::MergePullBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Merge, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_number_patch(&self, owner: &str, repo: &str, number: i32, body: ::models::PullUpdate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repo, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_pulls_post(&self, owner: &str, repo: &str, body: ::models::PullsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Pulls, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_readme_get(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ContentsPath, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_releases_assets_id_delete(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_releases_assets_id_get(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Asset, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_releases_assets_id_patch(&self, owner: &str, repo: &str, id: &str, body: ::models::AssetPatch, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Asset, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_releases_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Releases, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_releases_id_assets_get(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Assets, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_releases_id_delete(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_releases_id_get(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Release, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_releases_id_patch(&self, owner: &str, repo: &str, id: &str, body: ::models::ReleaseCreate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Release, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_releases_post(&self, owner: &str, repo: &str, body: ::models::ReleaseCreate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Release, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_stargazers_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_stats_code_frequency_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CodeFrequencyStats, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_stats_commit_activity_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CommitActivityStats, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_stats_contributors_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ContributorsStats, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_stats_participation_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ParticipationStats, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_stats_punch_card_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CodeFrequencyStats, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_statuses_ref_get(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ModelRef, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_statuses_ref_post(&self, owner: &str, repo: &str, _ref: &str, body: ::models::HeadBranch, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ModelRef, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_subscribers_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_subscription_delete(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_subscription_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Subscribition, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_subscription_put(&self, owner: &str, repo: &str, body: ::models::SubscribitionBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Subscribition, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_tags_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Tags, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_teams_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Teams, Error = Error<serde_json::Value>>>;
    fn repos_owner_repo_watchers_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn repositories_get(&self, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repositories, Error = Error<serde_json::Value>>>;
    fn search_code_get(&self, q: &str, order: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchCode, Error = Error<serde_json::Value>>>;
    fn search_issues_get(&self, q: &str, order: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchIssues, Error = Error<serde_json::Value>>>;
    fn search_repositories_get(&self, q: &str, order: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchRepositories, Error = Error<serde_json::Value>>>;
    fn search_users_get(&self, q: &str, order: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchUsers, Error = Error<serde_json::Value>>>;
    fn teams_team_id_delete(&self, team_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn teams_team_id_get(&self, team_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Team, Error = Error<serde_json::Value>>>;
    fn teams_team_id_members_get(&self, team_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn teams_team_id_members_username_delete(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn teams_team_id_members_username_get(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn teams_team_id_members_username_put(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn teams_team_id_memberships_username_delete(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn teams_team_id_memberships_username_get(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::TeamMembership, Error = Error<serde_json::Value>>>;
    fn teams_team_id_memberships_username_put(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::TeamMembership, Error = Error<serde_json::Value>>>;
    fn teams_team_id_patch(&self, team_id: i32, body: ::models::EditTeam, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Team, Error = Error<serde_json::Value>>>;
    fn teams_team_id_repos_get(&self, team_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::TeamRepos, Error = Error<serde_json::Value>>>;
    fn teams_team_id_repos_org_repo_put(&self, team_id: i32, org: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn teams_team_id_repos_owner_repo_delete(&self, team_id: i32, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn teams_team_id_repos_owner_repo_get(&self, team_id: i32, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_emails_delete(&self, body: ::models::UserEmails, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_emails_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserEmails, Error = Error<serde_json::Value>>>;
    fn user_emails_post(&self, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_followers_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn user_following_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn user_following_username_delete(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_following_username_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_following_username_put(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::User, Error = Error<serde_json::Value>>>;
    fn user_issues_get(&self, filter: &str, state: &str, labels: &str, sort: &str, direction: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issues, Error = Error<serde_json::Value>>>;
    fn user_keys_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>>;
    fn user_keys_key_id_delete(&self, key_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_keys_key_id_get(&self, key_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserKeysKeyId, Error = Error<serde_json::Value>>>;
    fn user_keys_post(&self, body: ::models::UserKeysPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserKeysKeyId, Error = Error<serde_json::Value>>>;
    fn user_orgs_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>>;
    fn user_patch(&self, body: ::models::UserUpdate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::User, Error = Error<serde_json::Value>>>;
    fn user_repos_get(&self, _type: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>>;
    fn user_repos_post(&self, body: ::models::PostRepo, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>>;
    fn user_starred_get(&self, direction: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>>;
    fn user_starred_owner_repo_delete(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_starred_owner_repo_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_starred_owner_repo_put(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_subscriptions_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserUserIdSubscribitions, Error = Error<serde_json::Value>>>;
    fn user_subscriptions_owner_repo_delete(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_subscriptions_owner_repo_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_subscriptions_owner_repo_put(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn user_teams_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::TeamsList, Error = Error<serde_json::Value>>>;
    fn users_get(&self, since: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn users_username_events_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn users_username_events_orgs_org_get(&self, username: &str, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn users_username_followers_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn users_username_following_target_user_get(&self, username: &str, target_user: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn users_username_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>>;
    fn users_username_gists_get(&self, username: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gists, Error = Error<serde_json::Value>>>;
    fn users_username_keys_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>>;
    fn users_username_orgs_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>>;
    fn users_username_received_events_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn users_username_received_events_public_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn users_username_repos_get(&self, username: &str, _type: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>>;
    fn users_username_starred_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn users_username_subscriptions_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
}


impl<C: hyper::client::Connect>DefaultApi for DefaultApiClient<C> {
    fn emojis_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Emojis, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/emojis?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Emojis, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn events_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/events?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Events, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn feeds_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Feeds, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/feeds?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Feeds, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_get(&self, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gists, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/gists?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gists, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_id_comments_comment_id_delete(&self, id: i32, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}/comments/{commentId}?{}", configuration.base_path, query_string, id=id, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn gists_id_comments_comment_id_get(&self, id: i32, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Comment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}/comments/{commentId}?{}", configuration.base_path, query_string, id=id, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Comment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_id_comments_comment_id_patch(&self, id: i32, comment_id: i32, body: ::models::Comment, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Comment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}/comments/{commentId}?{}", configuration.base_path, query_string, id=id, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Comment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_id_comments_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Comments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}/comments?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Comments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_id_comments_post(&self, id: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Comment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}/comments?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Comment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_id_delete(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn gists_id_forks_post(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}/forks?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn gists_id_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gist, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gist, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_id_patch(&self, id: i32, body: ::models::PatchGist, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gist, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gist, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_id_star_delete(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}/star?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn gists_id_star_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}/star?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn gists_id_star_put(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists/{id}/star?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn gists_post(&self, body: ::models::PostGist, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gist, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gists?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gist, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_public_get(&self, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gists, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/gists/public?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gists, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gists_starred_get(&self, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gists, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/gists/starred?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gists, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gitignore_templates_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gitignore/templates?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gitignore, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn gitignore_templates_language_get(&self, language: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::GitignoreLang, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/gitignore/templates/{language}?{}", configuration.base_path, query_string, language=language);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::GitignoreLang, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn issues_get(&self, filter: &str, state: &str, labels: &str, sort: &str, direction: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issues, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("filter", &filter.to_string());
            query.append_pair("state", &state.to_string());
            query.append_pair("labels", &labels.to_string());
            query.append_pair("sort", &sort.to_string());
            query.append_pair("direction", &direction.to_string());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/issues?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Issues, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn legacy_issues_search_owner_repository_state_keyword_get(&self, keyword: &str, state: &str, owner: &str, repository: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchIssuesByKeyword, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/legacy/issues/search/{owner}/{repository}/{state}/{keyword}?{}", configuration.base_path, query_string, keyword=keyword, state=state, owner=owner, repository=repository);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchIssuesByKeyword, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn legacy_repos_search_keyword_get(&self, keyword: &str, order: &str, language: &str, start_page: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchRepositoriesByKeyword, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("order", &order.to_string());
            query.append_pair("language", &language.to_string());
            query.append_pair("start_page", &start_page.to_string());
            query.append_pair("sort", &sort.to_string());
            query.finish()
        };
        let uri_str = format!("{}/legacy/repos/search/{keyword}?{}", configuration.base_path, query_string, keyword=keyword);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchRepositoriesByKeyword, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn legacy_user_email_email_get(&self, email: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchUserByEmail, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/legacy/user/email/{email}?{}", configuration.base_path, query_string, email=email);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchUserByEmail, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn legacy_user_search_keyword_get(&self, keyword: &str, order: &str, start_page: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchUsersByKeyword, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("order", &order.to_string());
            query.append_pair("start_page", &start_page.to_string());
            query.append_pair("sort", &sort.to_string());
            query.finish()
        };
        let uri_str = format!("{}/legacy/user/search/{keyword}?{}", configuration.base_path, query_string, keyword=keyword);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchUsersByKeyword, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn markdown_post(&self, body: ::models::Markdown, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/markdown?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn markdown_raw_post(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/markdown/raw?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn meta_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Meta, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/meta?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Meta, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn networks_owner_repo_events_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/networks/{owner}/{repo}/events?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Events, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn notifications_get(&self, all: bool, participating: bool, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Notifications, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("all", &all.to_string());
            query.append_pair("participating", &participating.to_string());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/notifications?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Notifications, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn notifications_put(&self, body: ::models::NotificationMarkRead, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/notifications?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn notifications_threads_id_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Notifications, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/notifications/threads/{id}?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Notifications, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn notifications_threads_id_patch(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/notifications/threads/{id}?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn notifications_threads_id_subscription_delete(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/notifications/threads/{id}/subscription?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn notifications_threads_id_subscription_get(&self, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Subscription, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/notifications/threads/{id}/subscription?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Subscription, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn notifications_threads_id_subscription_put(&self, id: i32, body: ::models::PutSubscription, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Subscription, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/notifications/threads/{id}/subscription?{}", configuration.base_path, query_string, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Subscription, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_events_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/events?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Events, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Organization, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Organization, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_issues_get(&self, org: &str, filter: &str, state: &str, labels: &str, sort: &str, direction: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issues, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("filter", &filter.to_string());
            query.append_pair("state", &state.to_string());
            query.append_pair("labels", &labels.to_string());
            query.append_pair("sort", &sort.to_string());
            query.append_pair("direction", &direction.to_string());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/issues?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Issues, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_members_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/members?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_members_username_delete(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/members/{username}?{}", configuration.base_path, query_string, org=org, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn orgs_org_members_username_get(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/members/{username}?{}", configuration.base_path, query_string, org=org, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn orgs_org_patch(&self, org: &str, body: ::models::PatchOrg, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Organization, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Organization, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_public_members_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/public_members?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_public_members_username_delete(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/public_members/{username}?{}", configuration.base_path, query_string, org=org, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn orgs_org_public_members_username_get(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/public_members/{username}?{}", configuration.base_path, query_string, org=org, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn orgs_org_public_members_username_put(&self, org: &str, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/public_members/{username}?{}", configuration.base_path, query_string, org=org, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn orgs_org_repos_get(&self, org: &str, _type: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("type", &_type.to_string());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/repos?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Repos, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_repos_post(&self, org: &str, body: ::models::PostRepo, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/repos?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Repos, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_teams_get(&self, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Teams, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/teams?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Teams, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn orgs_org_teams_post(&self, org: &str, body: ::models::OrgTeamsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Team, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/orgs/{org}/teams?{}", configuration.base_path, query_string, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Team, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn rate_limit_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RateLimit, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/rate_limit?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::RateLimit, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_archive_format_path_get(&self, owner: &str, repo: &str, archive_format: &str, path: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/{archive_format}/{path}?{}", configuration.base_path, query_string, owner=owner, repo=repo, archive_format=archive_format, path=path);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_assignees_assignee_get(&self, owner: &str, repo: &str, assignee: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/assignees/{assignee}?{}", configuration.base_path, query_string, owner=owner, repo=repo, assignee=assignee);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_assignees_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Assignees, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/assignees?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Assignees, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_branches_branch_get(&self, owner: &str, repo: &str, branch: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Branch, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/branches/{branch}?{}", configuration.base_path, query_string, owner=owner, repo=repo, branch=branch);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Branch, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_branches_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Branches, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/branches?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Branches, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_collaborators_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/collaborators?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_collaborators_user_delete(&self, owner: &str, repo: &str, user: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/collaborators/{user}?{}", configuration.base_path, query_string, owner=owner, repo=repo, user=user);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_collaborators_user_get(&self, owner: &str, repo: &str, user: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/collaborators/{user}?{}", configuration.base_path, query_string, owner=owner, repo=repo, user=user);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_collaborators_user_put(&self, owner: &str, repo: &str, user: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/collaborators/{user}?{}", configuration.base_path, query_string, owner=owner, repo=repo, user=user);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_comments_comment_id_delete(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/comments/{commentId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_comments_comment_id_get(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CommitComments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/comments/{commentId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::CommitComments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_comments_comment_id_patch(&self, owner: &str, repo: &str, comment_id: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CommitComments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/comments/{commentId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::CommitComments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_comments_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RepoComments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/comments?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::RepoComments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_commits_get(&self, owner: &str, repo: &str, since: &str, sha: &str, path: &str, author: &str, until: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Commits, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("since", &since.to_string());
            query.append_pair("sha", &sha.to_string());
            query.append_pair("path", &path.to_string());
            query.append_pair("author", &author.to_string());
            query.append_pair("until", &until.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/commits?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Commits, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_commits_ref_status_get(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RefStatus, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/commits/{ref}/status?{}", configuration.base_path, query_string, owner=owner, repo=repo, ref=_ref);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::RefStatus, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_commits_sha_code_comments_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RepoComments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/commits/{shaCode}/comments?{}", configuration.base_path, query_string, owner=owner, repo=repo, shaCode=sha_code);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::RepoComments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_commits_sha_code_comments_post(&self, owner: &str, repo: &str, sha_code: &str, body: ::models::CommitBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CommitComments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/commits/{shaCode}/comments?{}", configuration.base_path, query_string, owner=owner, repo=repo, shaCode=sha_code);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::CommitComments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_commits_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Commit, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/commits/{shaCode}?{}", configuration.base_path, query_string, owner=owner, repo=repo, shaCode=sha_code);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Commit, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_compare_base_id_head_id_get(&self, owner: &str, repo: &str, base_id: &str, head_id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CompareCommits, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/compare/{baseId}...{headId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, baseId=base_id, headId=head_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::CompareCommits, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_contents_path_delete(&self, owner: &str, repo: &str, path: &str, body: ::models::DeleteFileBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::DeleteFile, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/contents/{path}?{}", configuration.base_path, query_string, owner=owner, repo=repo, path=path);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::DeleteFile, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_contents_path_get(&self, owner: &str, repo: &str, path: &str, path2: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ContentsPath, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("path", &path2.to_string());
            query.append_pair("ref", &_ref.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/contents/{path}?{}", configuration.base_path, query_string, owner=owner, repo=repo, path=path);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ContentsPath, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_contents_path_put(&self, owner: &str, repo: &str, path: &str, body: ::models::CreateFileBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CreateFile, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/contents/{path}?{}", configuration.base_path, query_string, owner=owner, repo=repo, path=path);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::CreateFile, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_contributors_get(&self, owner: &str, repo: &str, anon: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Contributors, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("anon", &anon.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/contributors?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Contributors, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_delete(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_deployments_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RepoDeployments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/deployments?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::RepoDeployments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_deployments_id_statuses_get(&self, owner: &str, repo: &str, id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::DeploymentStatuses, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/deployments/{id}/statuses?{}", configuration.base_path, query_string, owner=owner, repo=repo, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::DeploymentStatuses, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_deployments_id_statuses_post(&self, owner: &str, repo: &str, id: i32, body: ::models::DeploymentStatusesCreate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/deployments/{id}/statuses?{}", configuration.base_path, query_string, owner=owner, repo=repo, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_deployments_post(&self, owner: &str, repo: &str, body: ::models::Deployment, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::DeploymentResp, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/deployments?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::DeploymentResp, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_downloads_download_id_delete(&self, owner: &str, repo: &str, download_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/downloads/{downloadId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, downloadId=download_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_downloads_download_id_get(&self, owner: &str, repo: &str, download_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Downloads, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/downloads/{downloadId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, downloadId=download_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Downloads, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_downloads_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Downloads, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/downloads?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Downloads, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_events_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/events?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Events, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_forks_get(&self, owner: &str, repo: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Forks, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("sort", &sort.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/forks?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Forks, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_forks_post(&self, owner: &str, repo: &str, body: ::models::ForkBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Fork, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/forks?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Fork, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repo, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Repo, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_blobs_post(&self, owner: &str, repo: &str, body: ::models::Blob, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Blobs, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/blobs?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Blobs, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_blobs_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Blob, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/blobs/{shaCode}?{}", configuration.base_path, query_string, owner=owner, repo=repo, shaCode=sha_code);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Blob, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_commits_post(&self, owner: &str, repo: &str, body: ::models::RepoCommitBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::GitCommit, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/commits?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::GitCommit, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_commits_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::RepoCommit, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/commits/{shaCode}?{}", configuration.base_path, query_string, owner=owner, repo=repo, shaCode=sha_code);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::RepoCommit, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_refs_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Refs, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/refs?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Refs, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_refs_post(&self, owner: &str, repo: &str, body: ::models::RefsBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::HeadBranch, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/refs?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::HeadBranch, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_refs_ref_delete(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/refs/{ref}?{}", configuration.base_path, query_string, owner=owner, repo=repo, ref=_ref);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_git_refs_ref_get(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::HeadBranch, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/refs/{ref}?{}", configuration.base_path, query_string, owner=owner, repo=repo, ref=_ref);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::HeadBranch, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_refs_ref_patch(&self, owner: &str, repo: &str, _ref: &str, body: ::models::GitRefPatch, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::HeadBranch, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/refs/{ref}?{}", configuration.base_path, query_string, owner=owner, repo=repo, ref=_ref);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::HeadBranch, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_tags_post(&self, owner: &str, repo: &str, body: ::models::Tag, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Tags, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/tags?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Tags, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_tags_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Tag, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/tags/{shaCode}?{}", configuration.base_path, query_string, owner=owner, repo=repo, shaCode=sha_code);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Tag, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_trees_post(&self, owner: &str, repo: &str, body: ::models::Tree, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Trees, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/trees?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Trees, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_git_trees_sha_code_get(&self, owner: &str, repo: &str, sha_code: &str, recursive: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Tree, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("recursive", &recursive.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/git/trees/{shaCode}?{}", configuration.base_path, query_string, owner=owner, repo=repo, shaCode=sha_code);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Tree, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_hooks_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Hook, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/hooks?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Hook, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_hooks_hook_id_delete(&self, owner: &str, repo: &str, hook_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/hooks/{hookId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, hookId=hook_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_hooks_hook_id_get(&self, owner: &str, repo: &str, hook_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Hook, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/hooks/{hookId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, hookId=hook_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Hook, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_hooks_hook_id_patch(&self, owner: &str, repo: &str, hook_id: i32, body: ::models::HookBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Hook, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/hooks/{hookId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, hookId=hook_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Hook, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_hooks_hook_id_tests_post(&self, owner: &str, repo: &str, hook_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/hooks/{hookId}/tests?{}", configuration.base_path, query_string, owner=owner, repo=repo, hookId=hook_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_hooks_post(&self, owner: &str, repo: &str, body: ::models::HookBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Hook, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/hooks?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Hook, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_comments_comment_id_delete(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments/{commentId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_issues_comments_comment_id_get(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments/{commentId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::IssuesComment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_comments_comment_id_patch(&self, owner: &str, repo: &str, comment_id: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments/{commentId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::IssuesComment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_comments_get(&self, owner: &str, repo: &str, direction: &str, sort: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("direction", &direction.to_string());
            query.append_pair("sort", &sort.to_string());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/comments?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::IssuesComments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_events_event_id_get(&self, owner: &str, repo: &str, event_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Event, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/events/{eventId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, eventId=event_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Event, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_events_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/events?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Events, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_get(&self, owner: &str, repo: &str, filter: &str, state: &str, labels: &str, sort: &str, direction: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issues, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("filter", &filter.to_string());
            query.append_pair("state", &state.to_string());
            query.append_pair("labels", &labels.to_string());
            query.append_pair("sort", &sort.to_string());
            query.append_pair("direction", &direction.to_string());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Issues, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_number_comments_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}/comments?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::IssuesComments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_number_comments_post(&self, owner: &str, repo: &str, number: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}/comments?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::IssuesComment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_number_events_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Events, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}/events?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Events, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_number_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issue, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Issue, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_number_labels_delete(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}/labels?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_issues_number_labels_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Labels, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}/labels?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Labels, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_number_labels_name_delete(&self, owner: &str, repo: &str, number: i32, name: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}/labels/{name}?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number, name=name);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_issues_number_labels_post(&self, owner: &str, repo: &str, number: i32, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}/labels?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Label, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_number_labels_put(&self, owner: &str, repo: &str, number: i32, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}/labels?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Label, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_number_patch(&self, owner: &str, repo: &str, number: i32, body: ::models::Issue, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issue, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues/{number}?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Issue, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_issues_post(&self, owner: &str, repo: &str, body: ::models::Issue, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issue, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/issues?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Issue, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_keys_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Keys, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/keys?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Keys, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_keys_key_id_delete(&self, owner: &str, repo: &str, key_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/keys/{keyId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, keyId=key_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_keys_key_id_get(&self, owner: &str, repo: &str, key_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserKeysKeyId, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/keys/{keyId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, keyId=key_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::UserKeysKeyId, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_keys_post(&self, owner: &str, repo: &str, body: ::models::UserKeysPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserKeysKeyId, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/keys?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::UserKeysKeyId, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_labels_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Labels, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/labels?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Labels, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_labels_name_delete(&self, owner: &str, repo: &str, name: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/labels/{name}?{}", configuration.base_path, query_string, owner=owner, repo=repo, name=name);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_labels_name_get(&self, owner: &str, repo: &str, name: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/labels/{name}?{}", configuration.base_path, query_string, owner=owner, repo=repo, name=name);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Label, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_labels_name_patch(&self, owner: &str, repo: &str, name: &str, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/labels/{name}?{}", configuration.base_path, query_string, owner=owner, repo=repo, name=name);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Label, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_labels_post(&self, owner: &str, repo: &str, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Label, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/labels?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Label, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_languages_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Languages, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/languages?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Languages, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_merges_post(&self, owner: &str, repo: &str, body: ::models::MergesBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::MergesSuccessful, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/merges?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::MergesSuccessful, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_milestones_get(&self, owner: &str, repo: &str, state: &str, direction: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Milestone, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("state", &state.to_string());
            query.append_pair("direction", &direction.to_string());
            query.append_pair("sort", &sort.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/milestones?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Milestone, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_milestones_number_delete(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/milestones/{number}?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_milestones_number_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Milestone, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/milestones/{number}?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Milestone, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_milestones_number_labels_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Labels, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/milestones/{number}/labels?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Labels, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_milestones_number_patch(&self, owner: &str, repo: &str, number: i32, body: ::models::MilestoneUpdate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Milestone, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/milestones/{number}?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Milestone, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_milestones_post(&self, owner: &str, repo: &str, body: ::models::MilestoneUpdate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Milestone, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/milestones?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Milestone, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_notifications_get(&self, owner: &str, repo: &str, all: bool, participating: bool, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Notifications, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("all", &all.to_string());
            query.append_pair("participating", &participating.to_string());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/notifications?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Notifications, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_notifications_put(&self, owner: &str, repo: &str, body: ::models::NotificationMarkRead, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/notifications?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_patch(&self, owner: &str, repo: &str, body: ::models::RepoEdit, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repo, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Repo, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_comments_comment_id_delete(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/comments/{commentId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_pulls_comments_comment_id_get(&self, owner: &str, repo: &str, comment_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullsComment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/comments/{commentId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PullsComment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_comments_comment_id_patch(&self, owner: &str, repo: &str, comment_id: i32, body: ::models::CommentBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullsComment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/comments/{commentId}?{}", configuration.base_path, query_string, owner=owner, repo=repo, commentId=comment_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PullsComment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_comments_get(&self, owner: &str, repo: &str, direction: &str, sort: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::IssuesComments, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("direction", &direction.to_string());
            query.append_pair("sort", &sort.to_string());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/comments?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::IssuesComments, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_get(&self, owner: &str, repo: &str, state: &str, head: &str, base: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Pulls, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("state", &state.to_string());
            query.append_pair("head", &head.to_string());
            query.append_pair("base", &base.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Pulls, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_number_comments_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullsComment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/{number}/comments?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PullsComment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_number_comments_post(&self, owner: &str, repo: &str, number: i32, body: ::models::PullsCommentPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullsComment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/{number}/comments?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PullsComment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_number_commits_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Commits, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/{number}/commits?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Commits, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_number_files_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Pulls, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/{number}/files?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Pulls, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_number_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::PullRequest, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/{number}?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PullRequest, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_number_merge_get(&self, owner: &str, repo: &str, number: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/{number}/merge?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_pulls_number_merge_put(&self, owner: &str, repo: &str, number: i32, body: ::models::MergePullBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Merge, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/{number}/merge?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Merge, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_number_patch(&self, owner: &str, repo: &str, number: i32, body: ::models::PullUpdate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repo, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls/{number}?{}", configuration.base_path, query_string, owner=owner, repo=repo, number=number);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Repo, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_pulls_post(&self, owner: &str, repo: &str, body: ::models::PullsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Pulls, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/pulls?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Pulls, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_readme_get(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ContentsPath, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("ref", &_ref.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/readme?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ContentsPath, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_releases_assets_id_delete(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/releases/assets/{id}?{}", configuration.base_path, query_string, owner=owner, repo=repo, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_releases_assets_id_get(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Asset, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/releases/assets/{id}?{}", configuration.base_path, query_string, owner=owner, repo=repo, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Asset, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_releases_assets_id_patch(&self, owner: &str, repo: &str, id: &str, body: ::models::AssetPatch, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Asset, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/releases/assets/{id}?{}", configuration.base_path, query_string, owner=owner, repo=repo, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Asset, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_releases_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Releases, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/releases?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Releases, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_releases_id_assets_get(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Assets, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/releases/{id}/assets?{}", configuration.base_path, query_string, owner=owner, repo=repo, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Assets, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_releases_id_delete(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/releases/{id}?{}", configuration.base_path, query_string, owner=owner, repo=repo, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_releases_id_get(&self, owner: &str, repo: &str, id: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Release, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/releases/{id}?{}", configuration.base_path, query_string, owner=owner, repo=repo, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Release, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_releases_id_patch(&self, owner: &str, repo: &str, id: &str, body: ::models::ReleaseCreate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Release, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/releases/{id}?{}", configuration.base_path, query_string, owner=owner, repo=repo, id=id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Release, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_releases_post(&self, owner: &str, repo: &str, body: ::models::ReleaseCreate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Release, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/releases?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Release, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_stargazers_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/stargazers?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_stats_code_frequency_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CodeFrequencyStats, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/stats/code_frequency?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::CodeFrequencyStats, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_stats_commit_activity_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CommitActivityStats, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/stats/commit_activity?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::CommitActivityStats, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_stats_contributors_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ContributorsStats, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/stats/contributors?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ContributorsStats, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_stats_participation_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ParticipationStats, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/stats/participation?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ParticipationStats, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_stats_punch_card_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::CodeFrequencyStats, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/stats/punch_card?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::CodeFrequencyStats, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_statuses_ref_get(&self, owner: &str, repo: &str, _ref: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ModelRef, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/statuses/{ref}?{}", configuration.base_path, query_string, owner=owner, repo=repo, ref=_ref);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ModelRef, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_statuses_ref_post(&self, owner: &str, repo: &str, _ref: &str, body: ::models::HeadBranch, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::ModelRef, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/statuses/{ref}?{}", configuration.base_path, query_string, owner=owner, repo=repo, ref=_ref);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ModelRef, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_subscribers_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/subscribers?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_subscription_delete(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/subscription?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn repos_owner_repo_subscription_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Subscribition, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/subscription?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Subscribition, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_subscription_put(&self, owner: &str, repo: &str, body: ::models::SubscribitionBody, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Subscribition, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/subscription?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Subscribition, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_tags_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Tags, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/tags?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Tags, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_teams_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Teams, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/teams?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Teams, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repos_owner_repo_watchers_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/repos/{owner}/{repo}/watchers?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn repositories_get(&self, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repositories, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/repositories?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Repositories, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn search_code_get(&self, q: &str, order: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchCode, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("order", &order.to_string());
            query.append_pair("q", &q.to_string());
            query.append_pair("sort", &sort.to_string());
            query.finish()
        };
        let uri_str = format!("{}/search/code?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchCode, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn search_issues_get(&self, q: &str, order: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchIssues, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("order", &order.to_string());
            query.append_pair("q", &q.to_string());
            query.append_pair("sort", &sort.to_string());
            query.finish()
        };
        let uri_str = format!("{}/search/issues?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchIssues, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn search_repositories_get(&self, q: &str, order: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchRepositories, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("order", &order.to_string());
            query.append_pair("q", &q.to_string());
            query.append_pair("sort", &sort.to_string());
            query.finish()
        };
        let uri_str = format!("{}/search/repositories?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchRepositories, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn search_users_get(&self, q: &str, order: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::SearchUsers, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("order", &order.to_string());
            query.append_pair("q", &q.to_string());
            query.append_pair("sort", &sort.to_string());
            query.finish()
        };
        let uri_str = format!("{}/search/users?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchUsers, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn teams_team_id_delete(&self, team_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}?{}", configuration.base_path, query_string, teamId=team_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn teams_team_id_get(&self, team_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Team, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}?{}", configuration.base_path, query_string, teamId=team_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Team, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn teams_team_id_members_get(&self, team_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/members?{}", configuration.base_path, query_string, teamId=team_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn teams_team_id_members_username_delete(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/members/{username}?{}", configuration.base_path, query_string, teamId=team_id, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn teams_team_id_members_username_get(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/members/{username}?{}", configuration.base_path, query_string, teamId=team_id, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn teams_team_id_members_username_put(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/members/{username}?{}", configuration.base_path, query_string, teamId=team_id, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn teams_team_id_memberships_username_delete(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/memberships/{username}?{}", configuration.base_path, query_string, teamId=team_id, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn teams_team_id_memberships_username_get(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::TeamMembership, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/memberships/{username}?{}", configuration.base_path, query_string, teamId=team_id, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::TeamMembership, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn teams_team_id_memberships_username_put(&self, team_id: i32, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::TeamMembership, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/memberships/{username}?{}", configuration.base_path, query_string, teamId=team_id, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::TeamMembership, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn teams_team_id_patch(&self, team_id: i32, body: ::models::EditTeam, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Team, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}?{}", configuration.base_path, query_string, teamId=team_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Team, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn teams_team_id_repos_get(&self, team_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::TeamRepos, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/repos?{}", configuration.base_path, query_string, teamId=team_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::TeamRepos, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn teams_team_id_repos_org_repo_put(&self, team_id: i32, org: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/repos/{org}/{repo}?{}", configuration.base_path, query_string, teamId=team_id, org=org, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn teams_team_id_repos_owner_repo_delete(&self, team_id: i32, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/repos/{owner}/{repo}?{}", configuration.base_path, query_string, teamId=team_id, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn teams_team_id_repos_owner_repo_get(&self, team_id: i32, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/teams/{teamId}/repos/{owner}/{repo}?{}", configuration.base_path, query_string, teamId=team_id, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_emails_delete(&self, body: ::models::UserEmails, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/emails?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_emails_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserEmails, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/emails?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::UserEmails, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_emails_post(&self, body: ::models::EmailsPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/emails?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_followers_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/followers?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_following_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/following?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_following_username_delete(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/following/{username}?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_following_username_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/following/{username}?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_following_username_put(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/following/{username}?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::User, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::User, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_issues_get(&self, filter: &str, state: &str, labels: &str, sort: &str, direction: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Issues, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("filter", &filter.to_string());
            query.append_pair("state", &state.to_string());
            query.append_pair("labels", &labels.to_string());
            query.append_pair("sort", &sort.to_string());
            query.append_pair("direction", &direction.to_string());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/user/issues?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Issues, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_keys_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/keys?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gitignore, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_keys_key_id_delete(&self, key_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/keys/{keyId}?{}", configuration.base_path, query_string, keyId=key_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_keys_key_id_get(&self, key_id: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserKeysKeyId, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/keys/{keyId}?{}", configuration.base_path, query_string, keyId=key_id);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::UserKeysKeyId, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_keys_post(&self, body: ::models::UserKeysPost, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserKeysKeyId, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/keys?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::UserKeysKeyId, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_orgs_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/orgs?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gitignore, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_patch(&self, body: ::models::UserUpdate, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::User, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::User, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_repos_get(&self, _type: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("type", &_type.to_string());
            query.finish()
        };
        let uri_str = format!("{}/user/repos?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Repos, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_repos_post(&self, body: ::models::PostRepo, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/repos?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }


        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Repos, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_starred_get(&self, direction: &str, sort: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("direction", &direction.to_string());
            query.append_pair("sort", &sort.to_string());
            query.finish()
        };
        let uri_str = format!("{}/user/starred?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gitignore, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_starred_owner_repo_delete(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/starred/{owner}/{repo}?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_starred_owner_repo_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/starred/{owner}/{repo}?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_starred_owner_repo_put(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/starred/{owner}/{repo}?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_subscriptions_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::UserUserIdSubscribitions, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/subscriptions?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::UserUserIdSubscribitions, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn user_subscriptions_owner_repo_delete(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/subscriptions/{owner}/{repo}?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_subscriptions_owner_repo_get(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/subscriptions/{owner}/{repo}?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_subscriptions_owner_repo_put(&self, owner: &str, repo: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/subscriptions/{owner}/{repo}?{}", configuration.base_path, query_string, owner=owner, repo=repo);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn user_teams_get(&self, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::TeamsList, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/user/teams?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::TeamsList, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn users_get(&self, since: i32, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/users?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn users_username_events_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/events?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn users_username_events_orgs_org_get(&self, username: &str, org: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/events/orgs/{org}?{}", configuration.base_path, query_string, username=username, org=org);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn users_username_followers_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/followers?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn users_username_following_target_user_get(&self, username: &str, target_user: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/following/{targetUser}?{}", configuration.base_path, query_string, username=username, targetUser=target_user);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn users_username_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Users, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Users, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn users_username_gists_get(&self, username: &str, since: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gists, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("since", &since.to_string());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/gists?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gists, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn users_username_keys_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/keys?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gitignore, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn users_username_orgs_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Gitignore, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/orgs?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Gitignore, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn users_username_received_events_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/received_events?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn users_username_received_events_public_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/received_events/public?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn users_username_repos_get(&self, username: &str, _type: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = ::models::Repos, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("type", &_type.to_string());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/repos?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::Repos, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn users_username_starred_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/starred?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn users_username_subscriptions_get(&self, username: &str, x_git_hub_media_type: &str, accept: &str, x_rate_limit_limit: i32, x_rate_limit_remaining: i32, x_rate_limit_reset: i32, x_git_hub_request_id: i32) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/users/{username}/subscriptions?{}", configuration.base_path, query_string, username=username);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }

        {
            let mut headers = req.headers_mut();
            headers.set_raw("X-GitHub-Media-Type", x_git_hub_media_type);
            headers.set_raw("Accept", accept);
            headers.set_raw("X-RateLimit-Limit", x_rate_limit_limit);
            headers.set_raw("X-RateLimit-Remaining", x_rate_limit_remaining);
            headers.set_raw("X-RateLimit-Reset", x_rate_limit_reset);
            headers.set_raw("X-GitHub-Request-Id", x_git_hub_request_id);
        }



        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

}
